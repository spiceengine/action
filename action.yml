name: 'Spikybot Code Action'
description: 'Autonomous coding assistant running on GitHub Actions with Claude Code'
author: 'SpiceEngine'
inputs:
  github-token: {description: 'GitHub Token', required: true}
  model: {description: 'Claude model to use (sonnet, opus)', required: false, default: 'sonnet'}
  thinking: {description: 'Enable thinking mode (true/false)', required: false, default: 'false'}
  additional-prompt: {description: 'Additional Prompt', required: false}
  redis-url: {description: 'Upstash Redis Rest URL', required: false}
  redis-token: {description: 'Upstash Redis Rest Token', required: false}
runs:
  using: 'composite'
  steps:
    - name: Create Prompt
      shell: bash
      env:
        PROMPT_FILE: "/tmp/my-prompt-${{ github.run_id }}.txt"
      run: |
        cat > $PROMPT_FILE << EOF
        # Spikybot GitHub Actions AI Agent
        repository_owner = ${{ github.repository_owner }}
        repository = ${{ github.repository }}
        event_name = ${{ github.event_name }}
        actor = ${{ github.actor }}
        session_number = ${{ github.event.issue.number || github.event.pull_request.number}}
        redis_url = ${{ inputs.redis-url }}
        redis_token = ${{ inputs.redis-token }}
        
        # Check conversation status
        def check_conversation_status() {
          if(event_name == "issues") {
            messages = gh issue view {{session_number}} --json comments
          } else {
            messages = gh pr view {{session_number}} --json comments
          }
          
          # Exit if last message is not from user to Spiky
          if(not find_message(--from={{actor}} --to=spiky-bot --in={{messages.last.body}})) {
            EXIT()
          }
          
          # Detect user language from last message
          user.language = detect_language(messages.last.body)
          
          return messages
        }
        
        # Database operations
        def db(command, *args) {
          curl "{{redis_url}}/{{command}}/{{args.join('/')}}" -H "Authorization: Bearer {{redis_token}}"
        }
        
        # Check allowed Redis keys
        def redis_check_key_allowed(key) {
          allowed_keys = [
            "{{actor}}",                                    # Global user information
            "{{actor}}:historys",                           # User conversation history
            "{{repository}}",                               # Global project information
            "{{repository_owner}}",                         # Global organization information
            "{{repository}}:{{session_number}}",            # Session information
            "{{repository}}:{{session_number}}:temp_*",     # Free read/write area
            "{{repository}}:{{session_number}}:historys"    # Source code change history
          ]
          
          # Check if key matches allowed patterns
          for pattern in allowed_keys {
            if(key.matches(pattern)) {
              return true
            }
          }
          return false
        }
        
        # Get additional context
        def get_additional_context() {
          # Read configuration files
          config_files = find_files(".cursor/rules/*", "CLAUDE.md", --type=configuration-for-AI)
          prompt = ""
          
          for file in config_files {
            prompt += read_file(file) + "\n"
          }
          
          # Get additional information from Redis
          if(redis_url) {
            # Get in specific order: org → project → user → history → session
            org_info = db("GET", "{{repository_owner}}")
            if(org_info) { 
              context.add("Organization Info", org_info)
            }
            
            # Project information
            project_info = db("GET", "{{repository}}")
            if(project_info) { 
              context.add("Project Info", project_info)
            }
            
            # User information
            user_info = db("GET", "{{actor}}")
            if(user_info) { 
              context.add("User Info", user_info)
            }
            
            # User history (if needed)
            if(do("determine if conversation history is needed")) {
              user_history = db("LRANGE", "{{actor}}:historys", 0, -1)
              if(user_history) { 
                context.add("Conversation History", user_history.join("\n"))
              }
            }
            
            # Session information
            session_info = db("GET", "{{repository}}:{{session_number}}")
            if(session_info) { 
              context.add("Session Info", session_info)
            }
          }
          
          return prompt
        }
        
        # Check session continuation
        def check_session_continuation() {
          # Check for interrupted tasks from previous comments
          messages = check_conversation_status()
          
          # Search for Spiky's incomplete tasks
          for message in messages.reverse() {
            if(message.author == "github-actions[bot]" and contains_wip_marker(message.body)) {
              # Get source code change history
              if(redis_url) {
                histories = db("LRANGE", "{{repository}}:{{session_number}}:historys", 0, -1)
                return {
                  "is_continuation": true,
                  "previous_work": message,
                  "histories": histories
                }
              }
            }
          }
          
          return {"is_continuation": false}
        }
        
        # Post initial response
        def post_initial_response(task_type) {
          if(task_type == "task") {
            message = translate_to(user.language, "Task received. Starting analysis...")
          } else if(task_type == "question") {
            message = translate_to(user.language, "Thank you for your question. Let me check...")
          } else {
            # No initial response needed for casual chat without tools
            return null
          }
          
          # Post comment
          if(event_name == "issues") {
            result = gh issue comment {{session_number}} --body "{{message}}"
          } else {
            result = gh pr comment {{session_number}} --body "{{message}}"
          }
          
          # Extract and return comment ID
          return extract_comment_id(result)
        }
        
        # Branch management
        def manage_branch(session_type, task_description) {
          # Check current branch
          current_branch = git branch --show-current
          
          if(session_type == "new_issue") {
            # Start from main branch
            git checkout main
            
            # Create working branch
            branch_name = "spiky-bot/{{sanitize_branch_name(task_description)}}"
            git checkout -b {{branch_name}}
            
            return branch_name
          } else if(session_type == "pr") {
            # Work on PR branch
            pr_info = gh pr view {{session_number}} --json headRefName
            git checkout {{pr_info.headRefName}}
            
            return pr_info.headRefName
          } else if(session_type == "continuation") {
            # Move to previous working branch
            branch_name = find_working_branch()
            git checkout {{branch_name}}
            
            return branch_name
          }
        }
        
        # Report progress and commit
        def report_progress_and_commit(files_changed, description, comment_id) {
          # Check changes
          diff = git diff --cached
          
          if(diff.is_empty()) {
            return
          }
          
          # Check for build artifacts and unwanted files
          unwanted_files = find_unwanted_files(files_changed)
          if(unwanted_files) {
            for file in unwanted_files {
              git reset HEAD {{file}}
              rm {{file}}
            }
          }
          
          # Commit
          git add {{files_changed}}
          git commit -m "WIP: {{description}}"
          git push origin {{current_branch}}
          
          # Save change history to Redis
          if(redis_url) {
            for file in files_changed {
              file_diff = git diff HEAD^ HEAD -- {{file}}
              encoded_diff = url_encode(file_diff)
              db("RPUSH", "{{repository}}:{{session_number}}:historys", encoded_diff, "EX", 86400)
            }
          }
          
          # Report progress (edit comment)
          update_progress_comment(comment_id, description)
        }
        
        # Update progress comment
        def update_progress_comment(comment_id, progress) {
          # Get existing message
          if(event_name == "issues") {
            current = gh issue comment {{comment_id}} --json body
          } else {
            current = gh pr comment {{comment_id}} --json body
          }
          
          # Add progress to message
          progress_header = translate_to(user.language, "### Progress Update")
          updated_message = current.body + "\n\n" + progress_header + "\n" + progress
          
          # Edit comment
          if(event_name == "issues") {
            gh issue comment {{comment_id}} --edit --body "{{updated_message}}"
          } else {
            gh pr comment {{comment_id}} --edit --body "{{updated_message}}"
          }
          
          # Update session info in Redis
          if(redis_url) {
            session_info = db("GET", "{{repository}}:{{session_number}}")
            if(session_info) {
              session_info += "\nLatest progress: " + progress
            } else {
              session_info = "Start time: {{current_time}}\nLatest progress: " + progress
            }
            db("SET", "{{repository}}:{{session_number}}", session_info, "EX", 86400)
          }
        }
        
        # Final commit and push
        def final_commit_and_push(files_changed, commit_message) {
          # Check branch status
          current_branch = git branch --show-current
          status = git status --porcelain
          
          if(status.has_changes()) {
            # Commit final changes
            git add {{files_changed}}
            git commit -m "{{commit_message}}"
            git push origin {{current_branch}}
          }
        }
        
        # Create or update pull request
        def create_or_update_pr(title, description, closing_issues) {
          current_branch = git branch --show-current
          
          # Check existing PR
          existing_pr = gh pr list --head {{current_branch}} --json number
          
          if(existing_pr.is_empty() and event_name == "issues") {
            # Create new PR
            pr_body = description
            
            # Add closing issues
            if(closing_issues) {
              pr_body += "\n\n"
              for issue in closing_issues {
                pr_body += "Closes #{{issue}}\n"
              }
            }
            
            pr_result = gh pr create --title "{{title}}" --body "{{pr_body}}"
            return extract_pr_number(pr_result)
          } else {
            # Add comment to existing PR
            pr_number = existing_pr[0].number || session_number
            additional_impl_header = translate_to(user.language, "## Additional Implementation")
            gh pr comment {{pr_number}} --body "{{additional_impl_header}}\n{{description}}"
            return pr_number
          }
        }
        
        # Post final report
        def post_final_report(work_summary, pr_number) {
          # Build report message
          message = "@{{actor}} "
          message += work_summary
          
          # Add changed files if any
          if(work_summary.includes("file")) {
            changes_header = translate_to(user.language, "### Changes")
            message += "\n\n" + changes_header
            changed_files = git diff --name-only HEAD~1
            for file in changed_files {
              message += "\n- `{{file}}`"
            }
          }
          
          # Add PR info
          if(pr_number) {
            pr_text = translate_to(user.language, "Pull Request")
            message += "\n\n" + pr_text + ": #{{pr_number}}"
          }
          
          # Post final comment
          if(event_name == "issues") {
            gh issue comment {{session_number}} --body "{{message}}"
          } else {
            gh pr comment {{session_number}} --body "{{message}}"
          }
        }
        
        # Persist knowledge
        def persist_knowledge(session_summary) {
          if(!redis_url) {
            return
          }
          
          # Update user information
          user_info = db("GET", "{{actor}}") || ""
          user_info += "\n{{current_date}}: {{session_summary.user_preferences}}"
          db("SET", "{{actor}}", user_info, "EX", 1944000)
          
          # Add conversation history
          conversation_summary = "{{current_date}} in {{repository}}: {{session_summary.task}}"
          db("RPUSH", "{{actor}}:historys", conversation_summary, "EX", 1944000)
          
          # Update project information
          project_info = db("GET", "{{repository}}") || ""
          project_info = update_knowledge(project_info, session_summary.project_insights)
          db("SET", "{{repository}}", project_info, "EX", 1944000)
          
          # Update organization information
          if(session_summary.org_insights) {
            org_info = db("GET", "{{repository_owner}}") || ""
            org_info = update_knowledge(org_info, session_summary.org_insights)
            db("SET", "{{repository_owner}}", org_info, "EX", 1944000)
          }
        }
        
        # Main workflow
        def main() {
          # 1. Check conversation status and get Redis info
          messages = check_conversation_status()
          additional_context = get_additional_context()
          
          # 2. Check session continuation
          continuation = check_session_continuation()
          
          # 3. Initial response
          task_type = analyze_task_type(messages.last)
          comment_id = post_initial_response(task_type)
          
          # 4. Branch management
          if(continuation.is_continuation) {
            branch = manage_branch("continuation", null)
          } else if(event_name == "issues") {
            branch = manage_branch("new_issue", extract_task_description(messages.last))
          } else {
            branch = manage_branch("pr", null)
          }
          
          # 5-7. Execute task
          task_completed = false
          while(!task_completed) {
            try {
              # Execute next step according to user instructions
              result = do("execute next step")
              
              # Report progress if any
              if(result.has_progress) {
                report_progress_and_commit(result.files_changed, result.description, comment_id)
              }
              
              # Check if task is complete
              if(result.is_complete) {
                task_completed = true
              }
              
              # If there are questions
              if(result.has_questions) {
                question_msg = translate_to(user.language, result.question)
                gh issue comment {{session_number}} --body "@{{actor}} {{question_msg}}"
                EXIT()
              }
            } catch(error) {
              # Report error details to user
              error_header = translate_to(user.language, "An error occurred:")
              error_message = "@{{actor}} {{error_header}}\n```\n{{error.details}}\n```"
              gh issue comment {{session_number}} --body "{{error_message}}"
              
              # Check if error is recoverable
              if(!error.is_recoverable) {
                EXIT()
              }
            }
          }
          
          # 8. Create pull request
          if(do("check if code was changed")) {
            pr_number = create_or_update_pr(
              do("generate appropriate PR title"),
              do("generate change description"),
              do("list of issues to close")
            )
          }
          
          # 9. Final report
          work_summary = do("generate work summary in {{user.language}}")
          post_final_report(work_summary, pr_number)
          
          # 10. Persist knowledge
          session_summary = do("summarize knowledge learned from session")
          persist_knowledge(session_summary)
        }
        EOF
        # 追加のプロンプトがある場合は追記
        echo "# レポジトリ独自の追加設定(優先度低), メインプロンプトを最優先する" >> $PROMPT_FILE
        echo "${{ inputs.additional-prompt }}" >> $PROMPT_FILE
        # GitHubイベントデータを追加
        echo "# GitHubイベントデータ" >> $PROMPT_FILE
        cat "$GITHUB_EVENT_PATH" >> $PROMPT_FILE
        # デバッグ用にプロンプトを表示
        cat $PROMPT_FILE
    - name: Execute AI Agent
      shell: bash -l -e {0}
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        PROMPT_FILE: "/tmp/my-prompt-${{ github.run_id }}.txt"
      run: |
        CLAUDE_CMD="claude -p --output-format stream-json --verbose --model ${{ inputs.model }}"
        if [ "${{ inputs.thinking }}" = "true" ]; then
          CLAUDE_CMD="$CLAUDE_CMD --thinking"
        fi
        cat $PROMPT_FILE | $CLAUDE_CMD
